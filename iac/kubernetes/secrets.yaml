apiVersion: v1
kind: Secret
metadata:
  name: jumpserver-secrets
  namespace: jumpserver
  labels:
    app.kubernetes.io/name: jumpserver
    app.kubernetes.io/instance: jumpserver
    app.kubernetes.io/component: secrets
type: Opaque
data:
  # Base64 encoded values - CHANGE THESE IN PRODUCTION!
  # To generate: echo -n "your-secret" | base64
  
  # SECRET_KEY: Generate with: cat /dev/urandom | tr -dc A-Za-z0-9 | head -c 50 | base64
  SECRET_KEY: Q2hhbmdlTWVfU2VjcmV0S2V5X0dlbmVyYXRlX1JhbmRvbV81MF9DaGFyYWN0ZXJzX0hlcmU=
  
  # BOOTSTRAP_TOKEN: Generate with: cat /dev/urandom | tr -dc A-Za-z0-9 | head -c 24 | base64
  BOOTSTRAP_TOKEN: Q2hhbmdlTWVfQm9vdHN0cmFwVG9rZW5fMjRfQ2hhcnM=
  
  # Database password
  DB_PASSWORD: Q2hhbmdlTWVfRGF0YWJhc2VQYXNzd29yZDEyMyE=
  
  # Database root password
  POSTGRES_PASSWORD: Q2hhbmdlTWVfRGF0YWJhc2VQYXNzd29yZDEyMyE=
  
  # Cache password (optional - can be empty)
  REDIS_PASSWORD: ""
  CACHE_PASSWORD: ""
---
apiVersion: v1
kind: Secret
metadata:
  name: jumpserver-tls
  namespace: jumpserver
  labels:
    app.kubernetes.io/name: jumpserver
    app.kubernetes.io/instance: jumpserver
    app.kubernetes.io/component: tls
type: kubernetes.io/tls
data:
  # Replace with your actual TLS certificate and key
  # Generate self-signed for testing:
  # openssl req -x509 -nodes -days 365 -newkey rsa:2048 \
  #   -keyout tls.key -out tls.crt \
  #   -subj "/CN=jumpserver.local"
  # kubectl create secret tls jumpserver-tls --cert=tls.crt --key=tls.key -n jumpserver --dry-run=client -o yaml
  tls.crt: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS0=
  tls.key: LS0tLS1CRUdJTiBQUklWQVRFIEtFWS0tLS0tCi0tLS0tRU5EIFBSSVZBVEUgS0VZLS0tLS0=
